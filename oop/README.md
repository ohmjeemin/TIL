### 객체 지향 프로그래밍 (OOP)

#### 객체

1. 객체를 보는 관점은 두 가지가 있다. 

   - 남이 보는 나
   - 자기 자신이 보는 나

   이렇게 관점이 다른 이유는 '컨텍스트'가 다르기 때문이다. '컨텍스트'는 role을 만든다. 객체는 role에 맞는 일을 수행해야 한다.

   

#### 객체 지향

2. 프로그램의 목적을 컨텍스트로 보고, 컨텍스트는 다양한 레이어를 가질 수 있다.

   ex) 웹사이트 layer > 보안 layer > 세션 layer ...

   한 개의 객체가 여러 컨텍스트를 수행하고 있다면 혼란스러워 지기 때문에 **한 개의 객체는 한 개의 컨텍스트를 수행**하게 만들어야 한다. 그렇기 때문에 객체는 어떤 컨텍스트를 수행하게 하기 위해 어떤 객체에게 **요청**할 지 알아야 한다. 이렇게 객체들은 서로 통신하게 되는데, 이 통신은 메세지를 통해 객체망으로 이루어진다.



#### 단일 책임 원칙(SRP)

3. 한 개의 객체가 여러 가지의 역할(context)을 수행하게 된다면 단일 책임 원칙에 위배된다. 객체가 의존성을 넘기려고 하는데, 누가 받을지 모르기 때문에 오류가 난다. 
   - 단일 책임 원칙은 결합도(수정 후 여파가 어디까지 인지)를 낮추고 응집도(각각의 역할)를 높힌다.
   - 한 객체가 많은 역할을 가지고 있다면 결합도가 높아진다.
   - 상황에 따라 더 유리한 결합 방식을 가지고 있다. 이것을 정리한 것을 **디자인 패턴**이라고 한다.



#### 은닉성과 캡슐화

4. 객체는 내부의 어떤 것도 보여주지 않는다. (은닉성)

5. 내부의 코드가 변해도 외부에서는 충격을 받지 않기 위해서 캡슐화를 한다.

   ex) 은행 ATM에서 '이체'라는 기능 내부에는 사실 수 많은 일을 하고 있다. (망 연결, 디비 연결, ...)

   캡슐화를 통해 로직보다 그 객체의 목적과 본질에 집중할 수 있다.

   ex) 50px 50px 보다 draw-small 로 표현하기

   ​	  left, right 보다 start, end로 표현



#### 객체 지향 프로그래밍

6. 수많은 컨텍스트를 만들어 놓고, 각각 컨텍스트를 맡아서 수행하다가 자신이 못하는 일이라면 다른 객체에 요청하는 것이다.

   - 객체 지향 프로그래밍에서는 남한테 미룰수록 좋다.

   - 남에게 요청하려면 dependency를 잘 알아야한다. 

   - 객체 식별 방법 

     - 포인터 값으로 값 식별

     - 값 식별

   - 인자에는 값이 들어가면 안되고, 객체만 받아야 한다. 

     (생성자만 값을 인자로 받을 수 있다. `new Age(23)`)



#### Value와 Identifier

7. value란, 메모리 주소와 상관없이 그 값이 같으면 같다고 하는 것이다.

   - 계속 복사본을 만들기 때문에 상태 변화에 안전하다.

   - 연산을 기반으로 로직을 전개한다.

8. identifier란, 주소값을 비교하는 것이다.

   - 하나의 원본을 가지고 있다.
   - 연산이 아닌 메세지를 기반으로 로직을 전개한다.



#### 대체 가능성

 9. 객체 지향 프로그래밍의 중요한 정의 첫 번째는 **대체 가능성**이다. 대체 가능성이란 즉, 다형성이다. 객체에서 자식이 부모를 대신할 수 있다. 

    메소드의 리턴 타입이 Parent인 경우, Child로 리턴 타입을 대체 가능하다.

    그러나 반대로 메소드의 리턴 타입이 Child인 경우, Parent로 리턴 타입을 대체할 수 없다.

    메소드의 매개 변수인 경우, Child 타입인 경우, Parent 타입으로 대신 받을 수는 있다. 더 작은 범위의 객체를 준다면 그 부족한 부분은 어떤 다른 방법으로 채울 수 있다.

    그러나 반대로 메소드의 매개 변수가 Parent 타입은 경우, Child 타입으로 대신 받을 수는 없다. 

<img src="https://blog.kakaocdn.net/dn/vU5TE/btq5MvtTlYK/KiV0je5wmDZsmNCewCARP0/img.png" alt="img" style="zoom: 50%;" />



#### 내적 동질성

10. 객체 지향 프로그래밍의 두 번째 중요한 개념은 **내적 동질성**이다. 내적 동질성이란 객체가 생성된 당시 메소드가 우선시 되는 것이다.

    다음 그림을 보자. 

    <img src="https://blog.kakaocdn.net/dn/cbfDRb/btq5KPGKI4R/0XZ5olqfrYZOGpWfdITG9k/img.png" alt="img" style="zoom: 50%;" />

    p 는 Child를 생성한 것이다. 그렇기 때문에 p.b()를 호출한다면 생성 당시 메소드인 Child에 있는 b 메소드를 호출할 것이다. 그러나 a메소드를 호출한 경우에는 Child 안에 a메소드가 없기 때문에 Parent의 a()를 호출하게 된다.



#### 알고리즘과 타입

로직에 필요한 값이 100 이상의 수이고 싶다면, 두 가지 방법으로 프로그래밍을 할 수 있다. 첫 번째는 알고리즘으로 확인하는 방법이다. 알고리즘은 runtime 시점에서 입력된 값이 100 이상인 수 인지 체크할 수 있다. 두 번째는 아예 100 이상인 수인 타입을 만드는 것이다. 이렇게 타입을 직접 만든다면 컴파일러 시점에서 에러가 나는지 확인할 수 있다. 아래와 같이 OverH라는 100 이상의 수인 타입을 만든다면 객체를 만들 때 부터 100 이하의 수를 생성한다면 오류가 날 것이다.

```kotlin
class OverH(val value:Int) {
    init {
        if(input<=100) throw -> Exception("err")
    }
}
```

```kotlin
fun plus(a:OverH, b:OverH){
    return a.value + b.value
}
```





---

### 결론

OOP(객체 지향 프로그래밍)는 컨텍스트를 파악하고 역할을 파악하여 객체망을 이용하는 것이다. 

