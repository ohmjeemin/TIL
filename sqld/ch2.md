# sql

### 1단원 - 데이터 모델과 성능



### 성능 데이터모델링

→ 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것이다.

- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가
- 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다
- 분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework비용을 최소화 할 수 있는 기회를 가지게 된다.

→ 순서

1. 데이터모델링을 할 때 정규화를 정확하게 수행한다.
2. 데이터베이스 용량 산정을 수행한다.
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입의 조정 등을 수행한다.

**이력모델**

- 시간에 따라 발생하는 데이터 형식을 이력이라고 한다.
- 이력 데이터는 시간에 따라 발생하고, 동일한 컬럼 유형에 발생한다.
- 시간에 따라 반복적으로 발생하기 때문에 다른 테이블에 비해 대량의 데이터가 테이블에 적재될 가능성이 크다.  → 데이터베이스에 발생하는 트랜잭션의 성능저하로 이어지는 경우가 있다.

**이력 테이블의 특징**

- 시간에 따라 발생
- 동일한 컬럼에 발생
- 대량데이터가 발생할 가능성이 높다
- 성능에 영향을 주는 경우가 많다

### "동일한 유형의 속성이 컬럼단위로 반복되는 경우"

- 제 1차 정규화의 대상이 된다.
- 반복적인 속성 나열 형태에서는 각 속성에 대해 or 연산자로 연결된 조건들이 사용되는데 이때 인덱스를 사용하지 않고 한번의 전체 데이터 스캔으로 처리되게 되어 성능 저하가 나타날 수 있게 된다.
- 모든 반복 속성에 인덱스를 생성하게 되면 검색 속도는 좋아지겠지만 반대급부적으로 너무 많은 인덱스로 인해 입력, 수정, 삭제의 성능이 저하된다.

### 반정규화

- 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(development)과 운영(maintanance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
- 반정규화를 적용하는 이유는 데이터를 조회할 때
    - 디스크 I/O량이 많아서 성능이 저하되거나
    - 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나
    - 컬럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우
    

### "한 테이블에 많은 컬럼들이 존재할 경우"

- 데이터가 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커지게 되어 디스크 I/O가 대량으로 발생할 수 있다.
- 트랜잭션이 접근하는 컬럼유형을 분석해서 자주 접근하는 컬럼들과 상대적으로 접근 빈도가 낮은 컬럼들을 구분하여 1:1로 테이블을 분리하면 디스크 I/O가 줄어들어 성능을 향상시킬 수 있다.
- 테이블 내에서 컬럼의 위치를 조정하는 것은 데이터 주로 채워지는 컬럼을 앞 쪽에 위치시키고, 데이터가 채워지지 않고 주로 NULL상태로 존재하는 컬럼들을 뒤쪽에 모아둠으로써 로우의 길이를 어느정도 감소시킬 수 있으나, NULL 상태이던 컬럼에 나중에 데이터가 채워지게 될 경우 더 많은 로우체인이 발생할 수도 있기 때문에 바람직한 해결책은 아니다.
- 자주 사용하는 칼럼들을 한데 모으고, 사용빈도가 낮은 컬럼들이나 미래 시점에 사용될 것으로 예상되는 컬럼들을 한데 모아 별도의 1:1 관계 엔터티로 분리하는 등 데이터 모델 설계 수정을 고려해보는 것이 좋다.

### 파티셔닝

하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고, 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다.

이 때 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리하여 데이터 엑세스 성능도 향상시키고, 데이터 관리 방법도 개선할 수 잇도록 테이블에 적용하는 기법

### 인덱스 설계

- 인덱스는 값의 범위에 따라 일정하게 정렬이 되어 있으므로,
1. 상수값으로 equal 조건으로 조회되는 컬럼이 가장 앞으로 나오고
2. 범위조회 하는 유형의 컬럼이 그 다음에 오는 것이 인덱스 엑세스 범위를 좁힐 수 있는 가장 좋은 방법이다. 
- '='로 들어온 조건에 해당하는 컬럼이 인덱스의 가장 앞쪽에 위치할 때 인덱스의 이용 효율성이 가장 높다.

⬇️중요

- 엔티티 간에 논리적 관계가 있을 경우 즉, 엔터티 간에 관계를 정의하여 관련 엔티티 상호간에 업무적인 연관성이 있음을 표현한 경우에는 → 조인이 자주 발생한다는 것을 의미한다. → 조인 성능을 향상시키기 위해 인덱스를 생성해주는 것이 좋다. 그러므로 자식 테이블에 FK에 대한 인덱스가 필요하다.
- 데이터베이스에 생성하는 FK constraints는 데이터 모델 상에 표현된 논리적 관계에 따라 관련 인스턴스 간에 일관성을 보장하기 위해 설계된 제약조건을 구현할 수 있도록 DBMS가 제공해주는 하나의 지원 기능으로 이해할 수 있다.

### 분산 데이터베이스를 적용

- 공통코드, 기준정보 등 마스터 데이터는 분산데이터베이스에 복제분산 적용
- 거의 실시간(near real time)업무적인 특성을 가지고 있을 때 분산데이터베이스 사용하여 구성 가능
- 백업 사이트를 구성할 때 간단하게 분산 기능 적용하여 구성
