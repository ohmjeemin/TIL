# sql

### 1. DBMS 아키텍처

- 쿼리 평가 엔진: 계획을 세우고 실행하는 DBMS의 핵심 기능을 담당하는 모듈
  - sql 구문 분석하고 어떤 순서로 기억장치의 데이터에 접근할 지 결정
  - 위의 계획을 실행 계획이라고 함
  - 실행계획에 기반을 둬서 데이터에 접근하는 방법을 접근 메서드라고 함
- 버퍼 매니저
- 디스크 용량 매니저
- 트랜잭션 매니저와 락 매니저
  - 많은 사람들이 동시에 데이터베이스에 접근할 때 트랜잭션 단위로 관리
  - 필요한 경우 데이터에 락 걸고, 요청을 대기시킴
- 리커버리 매니저



### 2강. DBMS와 버퍼

기억장치는 기억 비용(데이터를 저장하는데 소모되는 비용)에 따라 1,2,3차로 분류한다.

하드디스크가 메모리보다 기억 비용이 낮다(같은 비용으로 더 많은 데이터를 저장할 수 있다)

기억 비용이 낮으면(하드디스크) 많은 데이터를 영속적으로 저장할 수 있지만, 접근 속도는 떨어진다. ↔ 기억 비용이 높으면(메모리) 접근 속도가 빠르지만 많은 데이터를 영속적으로 저장하기 힘들다.

DBMS가 사용하는 대표적인 기억창지

- 하드디스크,  메모리

성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼 또는 캐시라고 부른다. 주로 메모리가 사용된다. 버퍼 매니저는 이런 고속 접근이 가능한 버퍼에 데이터를 어떻게, 어느정도의 기간 동안 올릴지를 관리

메모리 위의 두개의 버퍼

- 데이터 캐시, 로그 버퍼
  - 데이터 캐시 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용, 만약 내가 찾는 데이터가 데이터 캐시 내에 있다면, 저속 저장소에 접근하지 않고 처리 가능, 빠르다
  - 로그 버퍼 갱신 처리와 관련이 있다. 갱신 후 바로 데이터를 변경하는 것이 아니라, 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다 ✏️갱신 처리는 비동기로 이루어짐. 로그 버퍼에 변경 후 **COMMIT 시** 디스크로 정보를 복사한다.

데이터 캐시와 로그 버퍼의 크기

데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작다. 그 이유는 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문이다. 따라서 값비싼 메모리를 많이 사용하는 것보다는, 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각한 것이다.

추가적인 메모리 영역 '워킹 메모리'

정렬 또는 해시 관련 처리에 사용되는 작업용 영역

✏️찾아보깅

- [ ]  워킹 메모리는 정렬 또는 해시에만

- [ ] I/O에는 하드디스크만 있는지

  

### 3. DBMS가 쿼리를 읽어들여 데이터에 접근하는 방법

### 쿼리 평가 엔진

- 파서
  - 구문 분석
- 옵티마이저
  - 파서에서 통과되면 SQL을 최적화 시킴
  - 실행 계획을 세우고 여러 개가 나온다면 비교
- 카탈로그 매니저
  - 옵티마이저가 실행 계획을 세울 때 중요한 정보 제공
  - 테이블 또는 인덱스 정보 (통계 정보라고 함)
- 플랜 평가
  - 옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 최적의 실행 결과를 선택하는 것
  - 실행 계획이 선택되면, 이후 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행

### 옵티마이저와 통계 정보

**통계 정보**

- 테이블의 레코드 수
- 테이블의 필드 수와 필드 크기
- 카디널리티
- 히스토그램
- 필드 내부 NULL 수
- 인덱스 정보

옵티마이저가 정확하지 않은 통계 정보를 갖고 있으면 문제가 생김

그렇기 때문에 테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 갱신해야 한다.



### 4강

SQL지연이 발생하면 실행 계획을 가장 먼저 확인해봐야 한다

🟡 **실행 계획의 출력 포맷**

- 조작 대상 객체

- 객체에 대한 조작의 종류

  - Oracle에서는 Operation 필드
  - PostgreSQL에서 `Seq Scan`은 순차적인 접근

  ✏️아래 테이블 풀 스캔의 실행 계획 확인

- 조작 대상이 되는 레코드 수

  - Rows는 실제 테이블에서 읽은 게 아니라, 카탈로그 매니저로부터 받은 정보

🟡 **테이블 풀 스캔의 실행 계획**

PostgreSQL의 Seq Scan 과 Oracle의 TABLE ACCESS FULL은 같은 것은 아니다.

- Seq Scan :  순차적으로 접근해서 해당 테이블의 데이터 전체를 읽어낸다. 물리적 차원에 더 가까운 출력.
- TABLE ACCESS FULL : 테이블의 데이터를 전부 읽어들인다. 내부적으로 시퀀셜 스캔 수행.

🟡 **실행 계획의 실행 비용**과 **실행 시간**

- `DBMS_XPLAN.DISPLAY_CURSOR` 을 사용하면 조작마다 걸린 실행 시간을 출력할 수 있다.

🟡**인덱스 스캔의 실행 계획**

PostgreSQL은 `Index Scan`, Oracle에서는 `INDEX UNIQUE SCAN`이라는 조작

일반적으로는 스캔하는 모집합 레코드 수에서 선택되는 레코드 수가 적다면 테이블 풀 스캔보다 빠르게 접근 수행한다. 이는 풀 스캔이 모집합의 데이터양에 비례해서 처리 비용이 늘어나는 것에 반해, 인덱스를 사용할 때 활용되는 B-tree가 모집합의 모집합의 데이터양에 따라 대수 함수적으로 비용이 늘어나기 때문이다. 간단하게 말해서 인덱스의 처리 비용이 완만하게 증가한다라는 뜻으로, 특정 데이터양을 손익분기점으로 인덱스 스캔이 풀 스캔보다도 효율적인 접근을 하게 된다.

→ 모집합의 데이터가 많을수록 인덱스 스캔이 좋음

🟡 간단한 테이블 결합의 실행 계획 (JOIN 같은것)

- 3가지 종류의 알고리즘
  - Nested Loops : 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
  - Sort Merge: 결합 키로 레코드를 정렬하고, 순차적으로 두개의 테이블을 결합하는 방법, 결합 전에 전처리로 정렬을 수행해야 한다. 이 때 '워킹 메모리를 사용'
  - Hash: 결합 키값을 해시값으로 맵핑하는 방법. 해시 테이블을 만들어야 하는데 이 때 '워킹 메모리를 사용'

🟡 실행 계획을 읽는 방법

- 실행 계획은 일반적으로 트리 구조이고, 중첩 단계가 깊을수록 먼저 실행된다
- 같은 중첩 단계에서는 위에서 아래로 실행된다.



### 5강. 실행 계획의 중요성

옵티마이저의 실행 계획이 최적화된 것이 아니라면 실행 계획을 수정할 수 있다.



### 6강. SELECT 구문

RDB는 데이터를 관계(relation)라는 형식으로 저장한다. 구현으로는 이를 테이블(table)이라고 부른다.

SELECT 구문의 입력과 출력의 자료형은 테이블(관계)이다. 즉 2차원 표이다.

HAVING 구

- WHERE절은 레코드에 조건을 저장한다면, HAVING구는 집합에 조건을 지정

VIEW

자주 사용하는 SELECT구문을 데이터베이스 안에 저장하는 것

대신 VIEW는 데이터를 보유하지 않는다

VIEW는 사실  FROM 절에 서브쿼리를 이용하는 것이다

WHERE구의 조건에 서브쿼리를 사용하기

IN 사용

```sql
SELECT name FROM Address
WHERE name IN (SELECT name FROM Address2);
```

서브쿼리부터 실행된다



### 7강. 조건분기

SQL의 조건 분기는 식 기준으로 한다.

**CASE식의 구문**

1. 단순 CASE 식
2. 검색 CASE 식 (1을 포함)

SQL의 조건 분기는 특정한 값(상수)를 리턴한다.

CASE 는 식이라서 SELECT, WHERE, GROUP BY, HAVING, ORDER BY 구에 적을 수 있다.

### SQL의 집합연산

- UNION 합집합
  - → 문자 그대로 두 개의 테이블을 하나의 테이블로 합친 결과가 나옴
  - 중복된 데이터 제거
  - 만약 중복을 제외하고 싶지 않다면 UNION ALL 옵션을 붙인다
- INTERSECTION 교집합
- EXCEPT 차집합

### 윈도우 함수

- GROUP BY에서 자르기만 있는 것(집약 기능 삭제)
- 집약 함수 뒤에 OVER 구를 작성하고 내부에 자를 키를 지정하는 PARTITION BY 또는 ORDER BY를 입력한다.



### 8강. UNION을 사용한 쓸데없이 긴 표현

1. UNION을 사용한 조건 분기와 관련된 예제

UNION을 사용한 조건 분기는 하나의 SQL 구문을 실행하는 것처럼 보이지만, 내부적으로는 여러개의 SELECT 구문을 실행하는 실행 계획으로 해석됨

2001년까지는 세금이 포함되지 않은 가격을, 2002년부터는 세금이 포함된 가격을 price필드로 표시하게 되었다.

**UNION을 사용한 분기**

```sql
SELECT item_name, year, price_tax_ex AS price
FROM Items
WHERE year <= 2001
UNION ALL
SELECT item_name, year, price_tax AS price
FROM Items
WHERE year >= 2002;
```

문제점

- 쓸데없이 길다 → 거의 같은 두개의 쿼리를 두번이나 실행하고 있다.
- UNION 쿼리는 Items 테이블에 2회 접근한다 → 그때마다 TABLE ACCESS FULL이 발생하므로, 읽어들이는 비용도 테이블의 크기에 따라 선형으로 증가하게 된다.
- 물리 자원(저장소의 I/O비용)도 쓸데없이 소비하게 된다.

1. WHERE 구에서 조건 분기를 하는 사람은 초보자

   → SELECT 구만으로 조건 분기를 하면 최적화할 수 있다.

```sql
SELECT item_name, year,
			CASE WHEN year <= 2001 THEN price_tax_ex
			CASE WHEN year >= 2002 THEN price_tax_in END AS price
FROM items;
```

실행 계획

- 테이블에 대한 접근이 1회로 줄어든다.

SQL 구문의 성능이 좋은지 나쁜지는 반드시 실행 계획 레벨에서 판단해야 한다.



### 9강. 집계와 조건분기

count또는 sum과 같은 집약 함수의 결과는 1개의 레코드로 압축한다.

### 1. 집계 대상으로 조건 분기

- 집계의 조건 분기도 CASE식을 사용

  ```sql
  SELECT prefecture, 
  	SUM(CASE WHEN sex = '1' THEN pop ELSE 0 END) AS pop_men,
  	SUM(CASE WHEN sex = '2' THEN pop ELSE 0 END) AS pop_wom
  FROM Population
  GROUP BY prefecture;
  ```

### 2. 집약 결과로 조건 분기

- 집약에 조건 분기를 적용하는 또 하나의 패턴으로, 집약 결과에 조건 분기를 수행하는 경우가 있다.

```sql
SELECT emp_name
	MAX(team) AS team
FROM Employees
GROUP BY emp_name
HAVING count(*) = 1
UNION
SELECT emp_name
	MAX(team) AS team
FROM Employees
GROUP BY emp_name
HAVING count(*) = 2
UNION
SELECT emp_name
	MAX(team) AS team
FROM Employees
GROUP BY emp_name
HAVING count(*) >= 3
SELECT emp_name, 
	CASE WHEN COUNT(*)=1 THEN MAX(team)
			 WHEN COUNT(*)=2 THEN '2개를 겸무'
			 WHEN COUNT(*)=2 THEN '3개 이상을 겸무'
FROM Employees
GROUP BY emp_name;
```



### 10강. 그래도 UNION이 필요한 경우

- UNION을 사용할 수 밖에 없는 경우

  머지 대상이 되는 SELECT 구문들에서 사용하는 테이블이 다른 경우, 즉 여러 개의 테이블에서 검색한 결과를 머지하는 경우

- UNION을 사용하는 것이 성능적으로 더 좋은 경우

  - 인덱스와 관련된 경우

### UNION을 사용한 방법

### OR을 사용한 방법

🟡인덱스 사용 > 테이블 풀 스캔 성능비교

1. UNION을 써서 각각 머지하거나 2. where구문에 or 걸거나 같은 결과를 낼 수 있지만, where구문에 or을 사용하면 해당 필드에 부여된 인덱스를 사용할 수 없다.
2. 그럼 UNION과 OR의 성능 비교는 결국 3회의 인덱스 스캔 VS 1회의 테이블 풀 스캔 중에서 어떤 것이 더 빠른지에 대한 문제가 된다.
3. 이는 테이블 크기와 검색 조건에 따른 선택 비율에 따라 답이 달라진다. 하지만 테이블이 크고, where 조건으로 선택되는 레코드 수가 충분히 작으면 UNION이 더빠르다.

### IN을 사용한 방법

보기에는 더 간단하고 이해하기 쉬울 수 있지만 실행 계획은 OR을 사용했을 때와 같다.



### 13강. 자르기

- groupby는 집약과 자르기를 한다.

```sql
SELECT SUBSTRING(name, 1, 1) AS label, COUNT(*)
FROM person
GROUP BY SUBSTRING(name, 1, 1);
```

### 파티션

위와 같이 GROUP BY구로 잘라 만든하나하나의 부분 집합을 수학적으로는 파티션이라고 부른다.

파티션은 서로 중복되는 요소를 가지지 않는 부분 집합이다.

```sql
SELECT CASE WHEN age < 20 THEN '어린이'
						WHEN age BETWEEN 20 AND 69 THEN '성인'
						ELSE NULL END AS age_class, COUNT(*)
FROM person
GROUP BY CASE WHEN age < 20 THEN '어린이'
						WHEN age BETWEEN 20 AND 69 THEN '성인'
						ELSE NULL END;
```

자르기의 기준이 되는 키를 GROUP BY구와 SELECT 구 모두에 입력하는 것이 포인트이다.

GROUP BY 구에서 CASE식 또는 함수를 사용해도 실행 계획에는 영향이 없다.

### BMI로 자르기

→ GROUP BY 구엔 복잡한 식도 올 수 있다!

### PARTITION BY 구를 사용한 자르기

GROUP BY 구에서 집약 기능을 제외하고 자르는 기능만 남긴 것이 윈도우 함수의 PARTITION BY 구이다.

PARTITION BY 구를 사용해도 단순한 필드 이름뿐만 아니라 CASE식, 계산 식을 사용한 복잡한 기준을 사용할 수 있다.

```sql
SELECT name,age,
			CASE WHEN age < 20 THE '어린이',
						WHEN age BETWEEN 20 AND 69 THEN '성인'
						WHEN age >= 70 THEN '노인'
						ELSE NULL END AS age_class,
			RANK() OVER(PARTITION BY CASE WHEN age < 20 THE '어린이',
																		WHEN age BETWEEN 20 AND 69 THEN '성인'
																		WHEN age >= 70 THEN '노인'
																		ELSE NULL END
									ORDER BY age) AS age_rank_in_class
FROM person
ORDER BY age_class, age_rank_in_class;
```

### 💯 GROUP BY구는 입력 집합을 집약하므로 전혀 다른 레벨의 출력으로 변환하지만, PARTITION BY구는 입력에 정보를 추가할 뿐이므로 원본 테이블 정보를 완전히 그대로 유지한다!!!!!!



### 14강. 반복

- 포장계

  여러 행을 한꺼번에 처리하는 SQL

- 반복계

  SQL 처리를 단순화할 수 있다.

  - 단점
  - 처리하려는 레코드 수가 많아지면 성능이 떨어진다.

### sql의 오버헤드

- SQL을 실행할 때
- 전처리
  1. SQL 구문을 네트워크로 전송
  2. 데이터베이스 연결(최근 애플리케이션 단에서 미리 연결을 확보함 = '커넥션풀')
  3. SQL구문 파스
     1. 파스는 데이터베이스가 sql을 받을 때마다 실행됨
  4. **SQL구문의 실행 계획 생성 또는 평가**
- 후처리
  1. 결과 집합을 네트워크로 전송

> 데이터베이스에서 오버헤드 특정 작업을 수행할 때 메인 작업에 비해 부수적인 작업의 양이 지나치게 많을 때 데이터베이스 시스템 측변에서 부담이 된다는 의미

### 병렬분산 힘들다

반복계에서 실행하는 sql은 단순해서 I/O를 병렬화하기 힘들다.

결구.. 반복계는 단지 느린 것 뿐만 아니라 느린 구문을 튜닝할 수 이는 가능성도 거의 없다.



### 18강. 기능적 관점으로 구분하는 결합의 종류

- 내부 결합 - 데카르트 곱(크로스 결합)의 부분 집합

- 내부 결합과 같은 기능을 하는 상관 서브쿼리

  - 상관 서브쿼리 -  **Correlated Subquery 란?**

    바깥쪽 쿼리의 컬럼 중에 하나가 안쪽 서브쿼리의 조건에 이용하는 것이다.

    그 결과는 다시 바깥쪽 쿼리에 영향을 준다.

    기본 키를 사용하면 상관 서브쿼리를 스칼라 서브쿼리로 사용할 수 있다.

    ```sql
    // 내부 결합 실행 (inner join)
    select e.emp_id, e.emp_name, e,depth_id, d.dept_name
    from employees e inner join departments d
    on e.dept_id = d.dept_id;
    
    //서브쿼리로 변환
    select e.emp_id, e.emp_name, e.dept_id, (
    		select d.dept_name 
    		from departments d
    		where e.dept_id = d.dept_id
    	) as dept_name
    from employees e;
    ```

- 외부 결합 - 데카르트 곱의 부분 집합이 아니다. (때에 따라 부분 집합일수도)

- 자기 결합 - 연산의 대상으로 무엇을 사용하는지에 따른 분류이다.

  - 자기 결합 + 크로스 결합
  
  - 자기 결합 + 외부 결합
  
    

### 19강

### nested loop

- 중첩 반복을 사용하는 알고리즘
- 접근하는 레코드 수 R(A) x R(B)
- 구동테이블의 작을수록 성능이 좋다. (전제 - 내부 테이블의 결합 키 필드에 인덱스가 존재)
- 구동 테이블이 작은 Nested Loops + 내부 테이블의 결합 키에 인덱스 조합은 SQL 튜닝의 기본 중에 기본
- 내부 테이블의 레코드가 많다면
  - 구동 테이블로 큰 테이블을 선택
  - Hash 사용

### Hash

- 입력에 대해서 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수

### Hash 결합

1. 일단 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해서 해시값으로 변환
2. 다른 테이블(큰 테이블)을 스캔하고, 결합 키가 해시값에 존재하는 지를 확인하는 방법으로 결합을 수행한다.

- Hash가 사용되는 경우 어떤 한 쪽의 테이블이 극단적으로 크거나 작지 않다. 즉, 구동 테이블이라는 것을 지정하는 데에 의미가 없다.

**특징**

- 결합 테이블로부터 해시 테이블을 만들어서 활용하므로 , nested loops에 비해 메모리를 크게 소모한다.
- 메모리가 부족하면 저장소를 사용하므로 지연이 발생한다.
- 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용할 수 있당

**Hash가 유용한 경우**

- Nested Loops에서 적절한 구동테이블(상대적으로 충분히 작은 테이블)이 존재하지 않는 경우
- 앞서 'Nested Loops의 단점'에서 본 것처럼, 구동 테이블로 사용할만한 작은 테이블은 있지만, 내부 테이블에서 **히트**되는 레코드 수가 너무 많은 경우
- Nested Loops의 내부 테이블에 인덱스가 존재하지 않는(또는 여러 가지 사정에 의해 인덱스를 추가할 수 없는) 경우

**단점**

- 초기에 해시 테이블을 만들어야 하므로, Nested Loops에 비해 소비하는 메모리 양이 많다.
- Hash 결합은 반드시 양쪽 테이블의 레코드를 전부 읽어야 하므로, 테이블 풀 스캔이 사용되는 경우가 많다.

### Sort Merge

- Nested Loops가 비효율적인 경우
- 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합한다.
- Hash보다 더 많은 메모리를 사용한다.

### 의도하지 않은 크로스 결합



### 20강

### 최적의 결합 알고리즘을 결합 대상 레코드수의 관점에서 정리

- 소규모 - 소규모 : 어떤 알고리즘을 사용해도 성능 차이가 없다.
- 소규모 - 대규모 : 소규모 테이블을 구동 테이블로 하는 Nested Loop 사용
- 대규모 - 대규모 : Hash 사용

### 실행계획 제어

- Oracle은 Hint 구문으로 가능
- DB2는 전혀 불가능

sql 성능의 변동 위험을 줄이려면 되도록 결합을 피해야 한다.



### 21강

### 서브쿼리

- sql 내부에서 작성되는 일시적은 테이블 (이를 영속화한 것이 뷰)
- 서브쿼리는 같은 데이터를 저장하고 있는 경우라도 테이블에 비해 성능이 나쁜 경향이 있다.

### 테이블 vs 뷰 vs 서브쿼리

- 테이블: 영속적인 데이터를 저장
- 뷰: 영송적이지만 데이터는 저장하지 않음. 따라서 접근할 때마다 SELECT 구문이 실행됨
- 서브쿼리: 비영속적인 생존 기간(스코프)이 sql구문 실행 중으로 한정

##### SQL에서 제일 중요한 부분은 I/O를 줄이는 것이다. → 윈도우 함수로 결합을 제거한다.

